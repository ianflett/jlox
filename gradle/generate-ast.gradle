import java.nio.file.Files
import java.nio.file.Paths

tasks.register('defineAst') {
    group = 'build'
    description = 'Dynamically generates abstract syntax trees prior to compilation.'

    ext {
        sourceSet = project.sourceSets.main.java
        namespace = ''
        className = ''
        types = [:]
    }

    doLast {
        def targetDir = Paths.get(sourceSet.srcDirs?[0].toString(), namespace?.split(/\./)).toString()
        if (!Files.exists(Paths.get(targetDir))) file(targetDir).mkdirs()
        def path = Paths.get(targetDir, "${className}.java").toString()

        try (PrintWriter writer = new PrintWriter(path, 'UTF8')) {

            if (namespace?.trim()) {
                writer.println "package $namespace;"
                writer.println()
            }

            writer.println 'import java.util.List;'
            writer.println()
            writer.println "abstract class $className {"

            defineVisitor(writer, className, types.keySet())

            // AST classes.
            types.each { def type ->
                defineType(writer, className, type.key, type.value)
            }

            // Base accept() method.
            writer.println()
            writer.println '    abstract <R> R accept(Visitor<R> visitor);'

            writer.println '}'
        }
    }
}

compileJava.dependsOn defineAst

/**
 * Defines type within abstract syntax tree class.
 *
 * @param writer {@link PrintWriter} for output.
 * @param parentClassName Parent class's name.
 * @param subclassName Subclass's name.
 * @param fieldList List of fields.
 */
static void defineType(PrintWriter writer, String parentClassName, String subclassName, String fieldList) {

    writer.println()
    writer.println "    static class $subclassName extends $parentClassName {"

    // Constructor.
    writer.println "        $subclassName($fieldList) {"

    // Store parameters in fields.
    def fields = fieldList.split ', '
    fields.each { def field ->
        def name = field.split(' ')[1]
        writer.println "            this.$name = $name;"
    }

    writer.println '        }'

    // Visitor pattern.
    writer.println()
    writer.println '        @Override'
    writer.println '        <R> R accept(Visitor<R> visitor) {'
    writer.println "            return visitor.visit$subclassName$parentClassName(this);"
    writer.println '        }'

    // Fields
    writer.println()
    fields.each { def field ->
        writer.println "        final $field;"
    }

    writer.println '    }'
}

/**
 * Add new operation to each type in abstract syntax tree.
 *
 * @param writer {@link PrintWriter} for output.
 * @param parentTypeName Parent type's name.
 * @param typeNames All types to define.
 */
static void defineVisitor(PrintWriter writer, String parentTypeName, Set<String> typeNames) {

    writer.println()
    writer.println '    interface Visitor<R> {'

    typeNames.each { typeName ->
        writer.println "        R visit$typeName$parentTypeName($typeName ${parentTypeName.toLowerCase()});"
    }

    writer.println '    }'
}
