import java.nio.file.Files
import java.nio.file.Paths

tasks.register('defineAst') {
    group = 'build'
    description = 'Dynamically generates abstract syntax trees prior to compilation.'

    ext {
        sourceSet = project.sourceSets.main.java
        namespace = ''
        className = ''
        types = [:]
    }

    doLast {
        def targetDir = Paths.get(sourceSet.srcDirs?[0].toString(), namespace?.split(/\./)).toString()
        if (!Files.exists(Paths.get(targetDir))) file(targetDir).mkdirs()
        def targetFile = Paths.get(targetDir, "${className}.java").toString()

        new File(targetFile).withWriter { writer ->

            if (namespace?.trim()) {
                writer << """package $namespace;

"""
            }

            writer << """import java.util.List;

abstract class $className {
${          defineVisitor(className, types.keySet())}
${
            // AST classes.
            types.collect { def type ->
                defineType(className, type.key, type.value)
            }.join System.lineSeparator()
}

    abstract <R> R accept(Visitor<R> visitor);
}
"""
        }
    }
}

compileJava.dependsOn defineAst

/**
 * Outputs type within abstract syntax tree class.
 *
 * @param parentClassName Parent class's name.
 * @param subclassName Subclass's name.
 * @param fields List of fields.
 */
static String defineType(String parentClassName, String subclassName, List<String> fields) {

    """
    static class $subclassName extends $parentClassName {
        $subclassName(${fields.join(', ')}) {
${
    // Store parameters in fields.
    fields.collect { def field ->
        def name = field.split(' ')[1]
"            this.$name = $name;"
    }.join System.lineSeparator()
}
        }

        @Override
        <R> R accept(Visitor<R> visitor) {
            return visitor.visit$subclassName$parentClassName(this);
        }

${ // Fields.
fields.collect { def field ->
"        final $field;"
}.join System.lineSeparator()}
    }"""
}

/**
 * Add new operation to each type in abstract syntax tree.
 *
 * @param parentTypeName Parent type's name.
 * @param typeNames All types to define.
 */
static String defineVisitor(String parentTypeName, Set<String> typeNames) {

    """
    interface Visitor<R> {
${typeNames.collect { typeName ->
"        R visit$typeName$parentTypeName($typeName ${parentTypeName.toLowerCase()});"
}.join System.lineSeparator()}
    }"""
}
