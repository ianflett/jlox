import java.nio.file.Files
import java.nio.file.Paths

tasks.register('defineAst') {
    group = 'build'
    description = 'Dynamically generates abstract syntax trees prior to compilation.'

    ext {
        sourceSet = project.sourceSets.main.java
        definitions = [:]
    }

    doLast {
        for (def definition : definitions) {
            if (!definition.value instanceof Map || 0 == ((Map)definition.value).size())
                throw new IllegalArgumentException("Definition parameters must be a Map with entries");

            defineFile(sourceSet, definition.key, definition.value)
        }
    }
}

compileJava.dependsOn defineAst

static void defineFile(SourceDirectorySet sourceSet, String name, Map<String, List<String>> types) {

    def namespace = null
    def className = name.substring(name.lastIndexOf('.') + 1)
    if (name != className) {
        namespace = name.substring(0, name.lastIndexOf('.'))
    }

    def targetDir = Paths.get(sourceSet.srcDirs?[0].toString(), namespace?.split(/\./)).toString()
    if (!Files.exists(Paths.get(targetDir))) file(targetDir).mkdirs()
    def targetFile = Paths.get(targetDir, "${className}.java").toString()

    new File(targetFile).withWriter { writer ->

        if (namespace?.trim()) {
            writer << """package $namespace;

"""
        }

        writer << """import java.util.List;
import java.util.Objects;

abstract class $className {
${      defineVisitor(className, types.keySet())}
${
        // AST classes.
        types.collect { def type ->
            defineType(className, type.key, type.value)
        }.join System.lineSeparator()
}

    abstract <R> R accept(Visitor<R> visitor);
}
"""
    }
}

/**
 * Outputs type within abstract syntax tree class.
 *
 * @param parentClassName Parent class's name.
 * @param subclassName Subclass's name.
 * @param fields List of fields.
 */
static String defineType(String parentClassName, String subclassName, List<String> fields) {

    def fieldNames = fields.collect { it.split(' ')[1] }

    """
    static class $subclassName extends $parentClassName {
        $subclassName(${fields.join(', ')}) {
${
    // Store parameters in fields.
    fieldNames.collect {
"            this.$it = $it;"
    }.join System.lineSeparator()
}
        }

        @Override
        <R> R accept(Visitor<R> visitor) {
            return visitor.visit$subclassName$parentClassName(this);
        }

        /** {@inheritDoc} */
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (null == o || getClass() != o.getClass()) return false;
            var ${subclassName.toLowerCase()} = ($subclassName)o;

            return ${
        fieldNames.collect {"Objects.equals(this.$it, ${subclassName.toLowerCase()}.$it)" }.join " && "
    };
        }

        /** {@inheritDoc} */
        @Override
        public int hashCode() {
            return Objects.hash(${fieldNames.join ", "});
        }

${ // Fields.
fields.collect {
"        final $it;"
}.join System.lineSeparator()}
    }"""
}

/**
 * Add new operation to each type in abstract syntax tree.
 *
 * @param parentTypeName Parent type's name.
 * @param typeNames All types to define.
 */
static String defineVisitor(String parentTypeName, Set<String> typeNames) {

    """
    interface Visitor<R> {
${typeNames.collect {
"        R visit$it$parentTypeName($it ${parentTypeName.toLowerCase()});"
}.join System.lineSeparator()}
    }"""
}
