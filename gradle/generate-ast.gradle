import java.nio.file.Files
import java.nio.file.Paths

tasks.register('defineAst') {
    group = 'build'
    description = 'Dynamically generates abstract syntax trees prior to compilation.'

    ext {
        sourceSet = project.sourceSets.main.java
        namespace = ''
        className = ''
        types = [:]
    }

    doLast {
        def targetDir = Paths.get(sourceSet.srcDirs?[0].toString(), namespace?.split(/\./)).toString()
        if (!Files.exists(Paths.get(targetDir))) file(targetDir).mkdirs()
        def targetFile = Paths.get(targetDir, "${className}.java").toString()

        new File(targetFile).withWriter { writer ->

            if (namespace?.trim()) {
                writer << """package $namespace;

"""
            }

            writer << """import java.util.List;
import java.util.Objects;

abstract class $className {
${          defineVisitor(className, types.keySet())}
${
            // AST classes.
            types.collect { def type ->
                defineType(className, type.key, type.value)
            }.join System.lineSeparator()
}

    abstract <R> R accept(Visitor<R> visitor);
}
"""
        }
    }
}

compileJava.dependsOn defineAst

/**
 * Outputs type within abstract syntax tree class.
 *
 * @param parentClassName Parent class's name.
 * @param subclassName Subclass's name.
 * @param fields List of fields.
 */
static String defineType(String parentClassName, String subclassName, List<String> fields) {

    def fieldNames = fields.collect { it.split(' ')[1] }

    """
    static class $subclassName extends $parentClassName {
        $subclassName(${fields.join(', ')}) {
${
    // Store parameters in fields.
    fieldNames.collect {
"            this.$it = $it;"
    }.join System.lineSeparator()
}
        }

        @Override
        <R> R accept(Visitor<R> visitor) {
            return visitor.visit$subclassName$parentClassName(this);
        }

        /** {@inheritDoc} */
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (null == o || getClass() != o.getClass()) return false;
            var ${subclassName.toLowerCase()} = ($subclassName)o;

            return ${
        fieldNames.collect {"Objects.equals($it, ${subclassName.toLowerCase()}.$it)" }.join " && "
    };
        }

        /** {@inheritDoc} */
        @Override
        public int hashCode() {
            return Objects.hash(${fieldNames.join ", "});
        }

${ // Fields.
fields.collect {
"        final $it;"
}.join System.lineSeparator()}
    }"""
}

/**
 * Add new operation to each type in abstract syntax tree.
 *
 * @param parentTypeName Parent type's name.
 * @param typeNames All types to define.
 */
static String defineVisitor(String parentTypeName, Set<String> typeNames) {

    """
    interface Visitor<R> {
${typeNames.collect {
"        R visit$it$parentTypeName($it ${parentTypeName.toLowerCase()});"
}.join System.lineSeparator()}
    }"""
}
