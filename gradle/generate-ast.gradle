import java.nio.file.Files
import java.nio.file.Paths

tasks.register('defineAst') {
    group = 'build'
    description = 'Dynamically generates abstract syntax trees prior to compilation.'

    ext {
        sourceSet = project.sourceSets.main.java
        namespace = ''
        className = ''
        types = [:]
    }

    doLast {
        def targetDir = Paths.get(sourceSet.srcDirs?[0].toString(), namespace?.split(/\./)).toString()
        if (!Files.exists(Paths.get(targetDir))) file(targetDir).mkdirs()
        def path = Paths.get(targetDir, "${className}.java").toString()

        try (PrintWriter writer = new PrintWriter(path, 'UTF8')) {

            if (namespace?.trim()) {
                writer.println "package $namespace;"
                writer.println()
            }

            writer.println 'import java.util.List;'
            writer.println()
            writer.println "abstract class $className {"

            // AST classes.
            types.each { def type ->
                defineType(writer, className, type.key, type.value)
            }

            writer.println '}'
        }
    }
}

build.dependsOn defineAst

/**
 * Defines a type within an abstract syntax tree class.
 *
 * @param writer {@link PrintWriter} to use.
 * @param parentClassName Parent class's name.
 * @param subclassName Subclass's name.
 * @param fieldList List of fields.
 */
static void defineType(PrintWriter writer, String parentClassName, String subclassName, String fieldList) {

    writer.println "    static class $subclassName extends $parentClassName {"

    // Constructor.
    writer.println "        $subclassName($fieldList) {"

    // Store parameters in fields.
    def fields = fieldList.split ', '
    fields.each { def field ->
        def name = field.split(' ')[1]
        writer.println "            this.$name = $name;"
    }

    writer.println '        }'

    // Fields
    writer.println()
    fields.each { def field ->
        writer.println "        final $field;"
    }

    writer.println '    }'
}
